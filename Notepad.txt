Reflexions :
Reprendre a 0 et travailler avec des listes chainees.
Besoin de travailler avec un algorythme opti pour les longues listes et un autre pour les listes courtes, eventuellemet bruteforce.
C'est plus long que ca en avait l'air au premier abord.
Ne pas me rater sur le choix de l'algorythme, suivre les conseils, probablement un mix de quick sort et de merge sort

Bonus faciles : (savoir a quoi ressemble le bareme des bonus avant en crash test, et retry avec les bonus)
imprimer la liste avec -v
couleurs pour les derniers mouvements avec -c
eventuellement liste des operations que l'on peut afficher


_____________________________________________________________________________________________________________
Visualisation de l'etat d'une liste :



Configuration :
av = 5
spliter = 5 - 1 = 4 (tous les elements sont dans la pile a)
size = 4
|8|2|3|5|
list[0] = 8
list[1] = 2
list[2] = 3 = list[spliter - 2]
list[3] = 5 = list[spliter - 1]

Si on souhaite inverser les deux premiers elemnts de a il faut que qu'il y ait au moins 2 elements sur a 
=> donc sliter superieur ou egal a 2 => on ne fait rien si spliter inferieur a 2



Configuration :
av = 8
size = 7
spliter = 4 (4 elemts dans a et 3 dans b)
On effectue l'operation pb 3 fois (on effectue juste spliter--)
|8|2|3|5 | 6|1|4|


list[0] = 8							a
list[1] = 2							a
list[2] = 3 = list[spliter - 2]		a
list[3] = 5 = list[spliter - 1]		a

list[4] = 6 = list[spliter]			b
list[5] = 1 = list[size - 2]		b
list[6] = 6 = list[size - 1]		b
Si on souhaite inverser les deux
