Reflexions :
Reprendre a 0 et travailler avec des listes chainees.
Besoin de travailler avec un algorythme opti pour les longues listes et un autre pour les listes courtes, eventuellemet bruteforce.
C'est plus long que ca en avait l'air au premier abord.
Ne pas me rater sur le choix de l'algorythme, suivre les conseils, probablement un mix de quick sort et de merge sort

Bonus faciles : (savoir a quoi ressemble le bareme des bonus avant en crash test, et retry avec les bonus)
imprimer la liste avec -v
couleurs pour les derniers mouvements avec -c
eventuellement liste des operations que l'on peut afficher


_____________________________________________________________________________________________________________
Visualisation de l'etat d'une liste :



Configuration :
av = 5
spliter = 5 - 1 = 4 (tous les elements sont dans la pile a)
size = 4
|8|2|3|5|
list[0] = 8
list[1] = 2
list[2] = 3 = list[spliter - 2]
list[3] = 5 = list[spliter - 1]

Si on souhaite inverser les deux premiers elemnts de a il faut que qu'il y ait au moins 2 elements sur a 
=> donc sliter superieur ou egal a 2 => on ne fait rien si spliter inferieur a 2



Configuration :
av = 8
size = 7
spliter = 4 (4 elemts dans a et 3 dans b)
On effectue l'operation pb 3 fois (on effectue juste spliter--)
|8|2|3|5 | 6|1|4|


list[0] = 8							a
list[1] = 2							a
list[2] = 3 = list[spliter - 2]		a
list[3] = 5 = list[spliter - 1]		a

list[4] = 6 = list[spliter]			b
list[5] = 1 = list[size - 2]		b
list[6] = 6 = list[size - 1]		b
Si on souhaite inverser les deux

_____________________________________________________________________________________________________________
Strategie de resolution :
Quick sort
Ameliorer avec de l'insertion sort
Pour les petites listes, tout tester

Quand j'utilise un pivot, je laisse d'un cote ce qui est strictement inferieur et de l'autre ce qui est superieur ou egal.

_____________________________________________________________________________________________________________
make re && ARG=`ruby -e "puts (1..20).to_a.shuffle.join(' ')"`; ./push_swap $ARG
make re && ARG=`ruby -e "puts (1..20).to_a.shuffle.join(' ')"`; ./push_swap $ARG | ./checker $ARG
make re && ./push_swap $ARG

Todo demain : 
- descendre sous les 5500 pour 500
- Norme
- faire 5 petits bonus pour 125%

Liste des bonus :
- Afficher les etapes sur les mouvements sous forme de ligne
- Afficher un compteur de coups
- Couleurs
- Afficher les etapes sur les mouvements sous forme de pile
- scrypt de test
