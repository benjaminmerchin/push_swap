Reflexions :
Reprendre a 0 et travailler avec des listes chainees.
Besoin de travailler avec un algorythme opti pour les longues listes et un autre pour les listes courtes, eventuellemet bruteforce.
C'est plus long que ca en avait l'air au premier abord.
Ne pas me rater sur le choix de l'algorythme, suivre les conseils, probablement un mix de quick sort et de merge sort

Bonus faciles : (savoir a quoi ressemble le bareme des bonus avant en crash test, et retry avec les bonus)
imprimer la liste avec -v
couleurs pour les derniers mouvements avec -c
eventuellement liste des operations que l'on peut afficher


_____________________________________________________________________________________________________________
Visualisation de l'etat d'une liste :



Configuration :
av = 5
spliter = 5 - 1 = 4 (tous les elements sont dans la pile a)
size = 4
|8|2|3|5|
list[0] = 8
list[1] = 2
list[2] = 3 = list[spliter - 2]
list[3] = 5 = list[spliter - 1]

Si on souhaite inverser les deux premiers elemnts de a il faut que qu'il y ait au moins 2 elements sur a 
=> donc sliter superieur ou egal a 2 => on ne fait rien si spliter inferieur a 2



Configuration :
av = 8
size = 7
spliter = 4 (4 elemts dans a et 3 dans b)
On effectue l'operation pb 3 fois (on effectue juste spliter--)
|8|2|3|5 | 6|1|4|


list[0] = 8							a
list[1] = 2							a
list[2] = 3 = list[spliter - 2]		a
list[3] = 5 = list[spliter - 1]		a

list[4] = 6 = list[spliter]			b
list[5] = 1 = list[size - 2]		b
list[6] = 6 = list[size - 1]		b
Si on souhaite inverser les deux

_____________________________________________________________________________________________________________
Strategie de resolution :
Quick sort
Ameliorer avec de l'insertion sort
Pour les petites listes, tout tester

Quand j'utilise un pivot, je laisse d'un cote ce qui est strictement inferieur et de l'autre ce qui est superieur ou egal.

_____________________________________________________________________________________________________________
make re && ARG=`ruby -e "puts (1..20).to_a.shuffle.join(' ')"`; ./push_swap $ARG
make re && ARG=`ruby -e "puts (1..20).to_a.shuffle.join(' ')"`; ./push_swap $ARG | ./checker $ARG
make re && ./push_swap $ARG

Todo demain : 
- descendre sous les 700 en moyenne pour 100
	- passer a la recherche des quatres valeurs les plus eloignees
	- ne jamais cumuler deux fois de suite les valeurs les plus proches parmis les plus eloignees.
- commencer la strategie pour 500
	-
- descendre sous les 5500 pour 500

Todo apres demain :
- Norme
- faire 5 petits bonus pour 125%

Liste des bonus :
- Afficher les etapes sur les mouvements
- Afficher un compteur de coups
- Main de test
- Afficher les deux derniers coups en couleurs
- 



20 9 27 21 24 18 12 16 26 28 19 23 10 1 8 22 4 6 7 29 2 5 30 25 17 13 15 11 14 3